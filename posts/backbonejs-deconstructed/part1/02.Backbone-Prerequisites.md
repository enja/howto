# 2 - Backbone Prerequisites

## 2.1 - You Need Intermediate Knowledge of JavaScript and the DOM

Backbone abstracts a great deal of the repetitive tasks that can be accomplished with native DOM and HTML5 JavaScript APIs. Because of this, if you are not experienced with the DOM or with JavaScript, learning about a solution like Backbone might prove to be rather difficult, slow, and frustrating. Consider that Backbone itself reaches out for a third party solution (i.e. jQuery, Ender, or Zepto) for DOM manipulation and that is two layers of abstraction to get lost in if you do not already have a firm grip on native DOM scripting and modern JavaScript APIs (e.g. XHR). If you are not at least an intermediate JavaScript developer, you will mostly likely struggle with learning Backbone, as well as my words on the matter.

## 2.2 - You Need Experience with HTTP, XHR, and RESTful JSON APIs

Backbone comes with some helpers that make saving/syncing data to the backend trivial. Of course, a JSON API is assumed, so if you are not familiar with [HTTP](http://net.tutsplus.com/tutorials/tools-and-tips/http-the-protocol-every-web-developer-must-know-part-1/), [XHR](https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started), or reading and writing data to the server by using a [RESTful](http://www.restapitutorial.com/lessons/whatisrest.html) [JSON](https://developer.mozilla.org/en-US/docs/JSON) API, you might not clearly understand what Backbone is doing for you, or its value in doing it so that you don't have to.

## 2.3 - Experience with a Functional Programming Library

When Backbone was authored, a supporting library was created along with it, called [Underscore.js](http://underscorejs.org/), which provides the functional programming utilities used by Backbone. This library is a separate tool, which can be used without Backbone, but Backbone has a hard dependency on Underscore.js. Having experience with a functional programming utility library like Underscore.js or [Lo-Dash.js](http://lodash.com/) will help you not only understand the Backbone code better, it will also help you understand the functional methods that are inherited and usable on the Backbone [Model](http://backbonejs.org/#Model-Underscore-Methods) and [Collection](http://backbonejs.org/#Collection-Underscore-Methods) objects. If you have not spent any time gleaning the programming goodness found in Underscore.js or Lo-Dash.js, I highly suggest you spent some time in the trenches of one of these libraries.

## Notes:

- The functional programming utility library [Lo-Dash.js](http://lodash.com/) is a [drop-in replacement for Underscore.js](https://raw.github.com/lodash/lodash/v1.3.1/dist/lodash.underscore.js).
- At the very least, before you proceed learning Backbone, you should have a solid understanding of exactly what the utility method [extend()](http://underscorejs.org/#extend) is doing. It is the most used utility method in the Backbone source code. If you prefer Lo-Dash.js, keep in mind that the Lo-Dash.js library calls this [assign()](http://lodash.com/docs#assign) and `extend()` is an alias for `assign()`.

## 2.4 - You Need a Loose Understanding of Models and Views

Backbone strives to alleviate the “tangled piles of jQuery selectors and callbacks, all trying frantically to keep data in sync between the HTML UI”, and in the right hands, it does just that. However, it is just as easy to create a tangled pile of Backbone Events, Models, Collections, and Views. One can always just jump in and thrash about until they figure out how to swim in the Backbone pool, but a general understanding of a model and view will aid a developer when it comes to learning and implementing Backbone. Unfortunately, gaining even a loose conceptual understanding of application architecture patterns and sub-design patterns is challenging. I would recommend, at the very least, a general understanding of a model and view without getting tied up in a flavor of architecture for grounding the concept of a model or view. If you are starting with zero knowledge about a model or a view, I am going to offer a short Backbone-biased definition for each. If you feel strongly that you already have a conceptual understanding of a model and view, skip this section so I don't taint your previous knowledge.

**Model** - A model contains the state (i.e. the JSON data or what Backbone calls attributes) for an application, as well as a basic set of functionality (i.e. methods like [.set()](http://backbonejs.org/#Model-set) or [.get()](http://backbonejs.org/#Model-get) and events like [change](http://backbonejs.org/#Events-catalog)) for managing and listening to changes in the state/data. Additionally, the model orchestrates the storing of this state/data in memory in the browser, as well as persisting the state/data to the database on the server (i.e. syncing). An ordered grouping of models is a collection. In Backbone, collections are wrapped with a basic set of functionality for working with groups of models. The classic illustration of a model would be the data for a to-do item (i.e. the to-do and its state of completion), and a list of to-dos would be considered a collection of to-do models. If you think in terms of a table, the table would be the collection (i.e. to-dos), the headers in the table would be the model (i.e. title, status), and the content in the table rows would be the data (i.e. get a dog, done).

todo's (i.e. collection of to-do models)
title (i.e. model attribute)	status (i.e. model attribute)
get a dog (i.e. model attribute value)	done (i.e. model attribute value)

**View** - A view contains the logic to render an interactive UI of the state/data contained in models and collections of models. Views allow for state/data to be decoupled from the DOM so that multiple views can make use of the same models and collections. Thus, if you change a model or a model contained in a collection, multiple views can listen for these changes and update accordingly. So, ["the truth"](http://www.infoq.com/presentations/Getting-Truth-Out-of-the-DOM), or the state/data is not tied to the view; rather, it is decoupled from the view, or specifically, from the DOM/HTML.