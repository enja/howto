# 3 - Backbone.Model

## 3.1 - Conceptual Overview Of A `Backbone.Model`

## 3.1 - `Backbone.Model`の概念

A Backbone Model is likened to a table structure with column headers and rows of data.
A `Backbone.Model` object defines the column labels and wraps the data (i.e. attributes) in each row with pre-defined and custom methods for data conversions, validations, and access control.
Creating model instances from `Backbone.Model` or an extended `Backbone.Model`, provides the object to which the actual data is stored. For example, a model for a contact in a contacts application might look something like the following:

Backboneのモデルはテーブルの項目を定義し、行データを表現するようなものである。
`Backbone.Model`オブジェクトはカラムのラベルを定義し、データのデフォルト値や、データのやり取りやバリデート、アクセスのためのカスタムメソッドを内包する。
`Backbone.Model`または`Backbone.Model`から拡張されたクラスから、実際のデータが保持されるインスタンスを生成する。

| first name | last name | phone |
|------------|-----------|-------|
| John | Doe | 111-111-1111 |

You can think of a `Backbone.Model` constructor as the column headers and the methods and properties common to each row of data.
An instance created from the constructor is likened to populating the above table with actual data.

`Backbone.Model`のコンストラクタは列のヘッダ、行データと共通するメソッドと属性と考えることが出来る。
コンストラクタから作られたインスタンスは、テーブルに追加される実際のデータと紐付いている。

```js
//i.e.
new Backbone.Model(
    {firstName:'John',lastName:'Doe',phone:'1-111-1111'}
);
```

Keep in mind that out of the box `Backbone.Model` provides properties and methods (e.g. `get('phone')`) for operating on each row and facilitates the ability to define your own methods and properties (e.g. `getFullName()`)

`Backbone.Model`は各行の操作のための属性やメソッドを提供する（例えば`get('phone')`といったような）ものであり、独自の属性やメソッドも用意に追加出来るようになっている。

What's been summarized thus far is only part of the nature of a Backbone model.
In Backbone, the other part involves the logic for syncing data over HTTP through a restful JSON api using AJAX.
In this article we are going to save the details pertaining to syncing for another time. This article will focus on the life cycle of a model (and collection of models) without clouding this objective with syncing.

述べてきたのはBackboneのモデルの性質のほんの一部である。
その他の機能としてはAjaxでRESTなJSONのAPIをリクエストしデータを同期するロジックを含んでくる。
データの同期に関わる詳細についてはこの記事では触れないことにしよう。ここでは本題を逸らさないよう、モデルのライフサイクルに焦点をあてる。

## 3.2 - Subclassing and Creating a `Backbone.Model`

## 3.2 - `Backbone.Model`の生成とサブクラス化

To create a generic model with data we only need instantiate an instance from Backbone.Model and pass in the values (or what Backbone calls `attributes`) the model will store.
For example, below I create two contact models, one for John Doe and the other for Jane Doe.

データを扱う一般的なモデルを作るのに必要なのは、Backbone.Modelに保持される値（もしくはBackboneが呼び出す`attribtues`）を渡してインスタンスを作るだけである。
例として、John DoeとJane Doeの連絡先のモデルを以下に示す。

```js
var contact1Model = new Backbone.Model(
    {firstName:'John',lastName:'Doe',phone:'111-111-1111'}
);

var contact2Model = new Backbone.Model(
    {firstName:'Jane',lastName:'Doe',phone:'222-222-2222'}
);
```

However, it's more likely that you will be extending/subclassing the base `Backbone.Model` before you instantiate an instance so that you can add your own domain specific properties.

しかし、実際にはインスタンスを作る前に、ベースの`Backbone.Model`を拡張したサブクラスを作成することが多いと思うので、固有の属性等を追加することが可能だ。

Below I extend the `Backbone.Model` constructor, creating a sub-constructor, (i.e. `ContactModel`) and define the `getFullName()` method so all models created from `ContactModel` inherit the `getFullName()` method.

以下は、`Backbone.Model`のコンストラクタを拡張しサブクラス化して（ここでは`ContactModel`）、`getFullName()`というメソッドを定義することで、`ContactModel`から作られる全てのモデルに`getFullName()`メソッドを継承させることが出来る。

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/5gfv5/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

### Notes:

- An array of data can be passed in place of an object when instantiating a model. When this is done Backbone will convert the array to an object by giving numeric property names to the values passed (i.e. `['foo','bar']` becomes `{'1':'foo','2','bar'}`).
- The second argument that can be passed when instantiating a model, is an options object containing the options `collection`, `url`, `urlRoot`, and `parse` options. Most of these will be addressed in the next article given that they are related to syncing.
- Don't forget about the `initialize` function, which can be set up when extending models. This is an ideal place to house logic that needs to run when model instances are created. Especially considering that the `this` value inside of the initialize function is scope to the instance created.
- A convenient `clone()` method is available on model instances that will return a new instance of a model with a copy of the data the `clone()` method is called on. It is a handy way of creating a model from a model instance.

- モデルのインスタンスを作るときには、オブジェクトの代わりにデータの配列を渡すことが出来る。データの配列が渡されると、Backboneは、与えられた配列の添字をキーとして配列をオブジェクトに変換する（渡される配列が`['foo','bar']`であれば`{'1':'foo','2','bar'}`となる）。
- モデルのインスタンス化の際には、`collection`、`url`、`urlRoot`、`parse`オプションを含んだオブジェクトを第2引数として渡すことが出来る。ほとんどは次の記事で扱う予定のデータの同期について関係している。
- モデルを拡張する際にセットすることが出来る`initialize()`関数についても忘れてはならない。ここにはモデルをインスタンス化するときに実行させる必要があるロジックを配置する。特に、initialize関数内の`this`はインスタンス内を指すことを考慮しよう。
- 便利な`clone()`メソッドはモデルのインスタンスで実行することが可能で、同じデータを持つモデルのコピーを返す。これはモデルからモデルを作成するときに簡単な方法である。

## 3.3 - `Backbone.Model` Methods, Properties, And Events

Backbone model instances have the following [methods and properties](http://backbonejs.org/#View):

Backboneのモデルのインスタンスは以下の[メソッドとプロパティ](http://backbonejs.org/#View)を備えている。

- get
- set
- escape
- has
- unset
- clear
- id
- idAttribute
- cid
- attributes
- changed
- defaults
- toJSON
- **sync**
- **fetch**
- **save**
- destroy
- Underscore Methods:
    - keys
    - values
    - pairs
    - invert
    - pick
    - omit
- validate
- validationError
- isValid
- **url**
- **urlRoot**
- **parse**
- clone
- **isNew**
- **hasChanged**
- changedAttributes
- previous
- previousAttributes

The methods and properties in **bold** will not be discussed in this article. In the next article we will deal with the methods and properties in bold that pertain to syncing.

太字になっているメソッドとプロパティについてはこの記事では触れない。次の記事のデータの同期についての説明する時に取り扱うことになるだろう。

Additionally, models can make use of the following built-in events:

加えて、以下の元々あるイベントも便利に利用することが出来る。

| event type | arguments passed to callback | description |
|------------|------------------------------|-------------|
| `'all'`    | event name                   | this special event fires for any (i.e. not just built in events) triggered event, passing the event name as the first argument |
| `'change'` | model, options | when a model's attributes have changed. |
| `'change:[attribute]'` | model, value, options | when a specific attribute has been updated. |
| `'destroy'` | model, collection, options | when a model is [destroyed](http://backbonejs.org/#Model-destroy). |
| `'error'` | model, xhr, options | when a model's [save](http://backbonejs.org/#Model-save) call fails on the server. |
| `'invalid'` | model, error, options | when a model's [validation](http://backbonejs.org/#Model-validate) fails on the client. |
| `'request'` | model, xhr, options | when a model or collection has started a request to the server. |
| `'sync'` | model, resp, options | when a model (or collection) has been successfully synced with the |

## 3.4 - Setting Default Model Values/Attributes

When extending a model, you can provide a set of default values that are shared among all instances. In the code below I setup a default value for `firstName` and `lastName`.

モデルを拡張する際には、インスタンス全てに適用される初期値を指定することが出来る。次のコード例では、`firstName`と`lastName`に対しデフォルトの値を設定している。

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/8TQQR/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

If you would prefer that instances not reference the same default object, you can provide a function value for defaults that will create unique default values (i.e. not referencing that same default object).

もしデフォルトのオブジェクトを参照し固定値としたくないのであれば、一意な値を初期値を生成する関数として定義することも可能だ。

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/WzpwE/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

In the code example above, each instance will now make use of a unique `defaults` object, instead of each instance referencing the same `defaults` object.

上のサンプルでは、それぞれのインスタンスが共通の`defaults`オブジェクトを参照するのではなく、ユニークな`defaults`オブジェクトを参照している。

## 3.5 - Setting, Verifying, Getting, UnSetting, and Clearing Model Data

## 3.5 - モデルのデータの設定、確認、取得、削除、クリア

Backbone provides a generic set of methods (`set()`, `has()`, `get()`, `unset()`, `clear()`) for working with model data. Below I demonstrate each of these methods.

Backboneはモデルのデータを取り扱うために基本的なメソッド群を用意している（`set()`、`has()`、`get()`、`unset()`、`clear()`）。以下はそれらのデモンストレーションである。

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/Xh37w/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

### Notes:

- These methods should be used instead of directly editing the internal `attributes` object so the built in events on models can be triggered appropriately.
- The `set()`, `unset()`, and `clear()` methods invoke the internal `change` event.
- The `set()` method accepts an options object (e.g. `set({'name':'value','name':'value'})`) or two string parameters (e.g. `set('name','value')`).
- The `set()`, `unset()`, and `clear()` methods all accept the `{silent: true}` option which stops any Backbone built-in event form firing.
- The option `{validate:true}` can be used with the `set()` method to validate any values before they are set (e.g. `set({'foo':'foo'},{validate:true})`).

- モデルを更新する場合は、`attributes`オブジェクトを直接編集するのではなくこれらのメソッドを使うべきであり、そうすることでモデルのイベントが適切に発火される。
- `set()`、`unset()`、`clear()`は`change`イベントをトリガーする。
- `set()`メソッドには単一のオブジェクト（`set({'name':'value','name':'value'})`）か、文字列を2つ（`set('name','value')`）、引数として渡すことが出来る。
- `set()`、`unset()`、`clear()`には全て`{silent: true}`を渡すことが可能で、このオプションが渡されるとBackboneが内包するイベントが発火されない。
- `set()`メソッドには`{validate:true}`を渡すことが可能で、セットされるデータをバリデートすることが出来る。

## 3.6 - Accessing A Models Data/Attributes

Backbone provides the `attributes` property which gives direct access to the internal object containing a models data.

Backboneは、モデルの内部データに直接アクセス可能な`attributes`プロパティを提供する。

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/cWujE/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

While Backbone provides direct access to this object, it is not common for this object to be manipulated directly. In fact, don't do it. If you want to edit model data use `set()`, `get()`, `unset()`, `clear()` or make a copy (e.g. `model.toJSON();`) of the `attributes` object, edit that, then update the model using `set()`.

Backboneはこのオブジェクトに直接アクセスする方法を提供しているものの、基本的にはこれらは直接操作されるべきではない。実際にも、しないで欲しい。モデルのデータを操作したい時は、`set()`、`get()`、`unset()`、`clear()`を通して行うか、`attributes`オブジェクトのコピーを作って、編集したデータを`set()`に渡してモデルを更新しよう。

### Notes:

- Direct Manipulation of the `attributes` property will not invoke internal model events.

- `attributes`プロパティを直接編集しても、モデル内部のイベントは発火されない。

## 3.7 - Getting A Copy Of A Models Data/Attributes Using `toJSON()`

The `toJSON()` model method returns a copy of the `attributes` internal data object.

モデルの`toJSON()`関数は、`attributes`が持つ内部データのコピーを返す。

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/7cn5G/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

This can be handy when you need a clean copy of the object for a template.

テンプレートのために、クリーンなコピーを得たい時に簡単な方法である。

### Notes:

- The `toJSON()` method makes a shallow copy (i.e. [_.clone](http://underscorejs.org/#clone)) of the attributes object. Any nested object or arrays will be referenced from original, not copied.
- Passing a model instance to `JSON.stringify` will internally use the Backbone `toJSON()` method.

- `toJSON()`関数はattributesオブジェクトのシャローコピー（[_.clone](http://underscorejs.org/#clone)）を生成する。ネストしているオブジェクトや配列はコピー元から参照され、コピーされない。
- モデルのインスタンスを`JSON.stringify`に通すと、内部的にはBackboneの`toJSON()`が使われる。

## 3.8 - Filtering Model Data

## 3.8 モデルのデータのフィルタリング

Backbone proxies 6 methods (`keys()`, `values()`, `pairs()`, `invert()`, `pick()`, `omit()`) from the underscore.js library to be used directly on model data. These functions provide aid when filtered states of model data are needed. Below I demonstrate the four most used methods.

Backboneにはunderscore.jsから継承される6つのメソッド（`keys()`, `values()`、`pairs()`、`invert()`、`pick()`、`omit()`）があり、モデルの中で直接使われる。これらのメソッドはモデルのデータをフィルタしたい場合に役立つ。以下で、最も使われる4つのメソッドをデモしている。

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/kXKTb/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## 3.9 - Listening To Model `change` Events

## 3.9 モデルの`change`イベントの監視

Anytime a change occurs with a model's data a `change` event is broadcasted so that typically a view can listen for such an event.

モデルのデータが変更した時に発生する`change`イベントは伝播するので、ビューでも補足することが出来る。

In the following code example, a model is created and then a view is created to listen for changes on the model using the `change` event. Any changes to the model data will trigger a `change` event and then ideally a re-render.

次のコード例では、モデルが作成されると同時に、ビューがモデルの変更を`change`イベントで監視している。モデルのデータが変更されると`change`イベントが発火され、再描画される。

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/baMYn/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

It is possible to listen only for a specific attribute change in a model by indicating the name of the attribute along with the change event when the event listener is setup (i.e. `'change:[ATTRIBUTE]'`). For example, in the code below, I have changed the previous code example to only listen for changes on the `firstName` attribute in the contact model.

changeイベントのセットアップ時に、属性名も付与する（`'change:[ATTRIBUTE]'`のように）ことで特定の属性の変更のみを監視することも可能だ。例えば次のコードは、先程のコード例から、連絡先モデルの`firstName`属性の変更のみを監視するように変更してある。

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/xBkBY/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## 3.10 - Verify if a Model Has Changed And What Changed Using `hasChanged()` and `changedAttributes()`

## 3.10 `hasChanged()`と`changedAttributes()`を使った、モデルが変更されたか、何が変更されたかの確認

The `hasChanged()` and `changedAttributes()` model methods provide the ability to determine if something has changes since that last `change` event and specifically what changed.

モデルの`hasChanged()`と`changedAttributes()`メソッドを使うことで、前回`change`イベントが発火したときから何が変更されたかを特定することが出来る。

In the following code, I set up a contact model and then immediately changed the phone number attribute.

次のコードでは、連絡先のモデルを設定後、すぐに電話番号を変更している。

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/R8n89/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

By changing the phone number in the above code example, the internal `change` event is called for the first time and the `hasChanged()` method will return a boolean indicating that the model has changed. To get an object containing the attributes that have change invoke the `changedAttibutes()` method on the model.

電話番号を変更することで、最初の`change`イベントがトリガーされ、`hasChanged()`メソッドが、モデルが変更されたことを示す真偽値を返す。変更された属性をオブジェクトとして取得するには、モデルの`changedAttributes()`を実行する。

## 3.11 - Getting Previous Attribute Values Using `previous()` and `previousAttributes()`

## 3.11 - `previous()`と`previousAttributes()`を使った以前の属性値の取得

The `previous()` and `previousAttributes()` method can be used to get the value of an attribute prior to the last `change` event. In the following code example, I set up a contact model, change the `phone` and `firstName` attributes and then use the `previous()` and `previousAttributes()` method to retrieve the prior value for the phone attribute and the state of all mode attributes before the last change event.

`previous()`と`previousAttributes()`メソッドでは属性が持つ、`change`イベントの直前の値を取得することが可能だ。次のコード例では、連絡先モデルを作成し、`phone`と`firstName`の値を変更した後に、`previous()`と`previousAttributes()`を使って、changeイベントの直前のphoneの値とモデルの属性全てを取得している。

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/jyLzH/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## 3.12 - Validating Model Data Before Its Set or Saved

## 3.12 - モデルのデータの設定・保存時のバリデート

When setting or saving model data (we will talk about saving in the next article) a validation function can be invoked on the data validating its quality before anything is set or saved.

モデルのデータを設定や保存時（保存については次の記事で扱う予定）に、データの整合性等を担保するため、バリデート関数を実行させることが出来る。

By default, the `validate` property is left undefined. To define a validate function on a model pass `validate:function(attributes,options){}` to `extend()` or directly update the `validate` property on a model instance. To trip a validation error simply return any value from the function except `false`.

デフォルトでは`validate`プロパティはundefinedとなっている。モデルの`extend()`に`validate:function(attributes,options){}`を指定するか、モデルのインスタンスの`validate`プロパティを直接更新することで、バリデート関数を定義することが出来る。エラーをトリップするには、関数の中で`false`以外の何らかの値を返せば良い。

In the code below, I set up a validation function for phone numbers and make sure any invalid phones numbers can not be `set()`.

以下のコードでは、電話番号のバリデーション関数を指定し、無効な値が`set()`を通してセットされないようにしてある。

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/w5ug9/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

The last value returned from the validation function that is not false, can be referenced from the models `validationError` property. In the code above we return an invalid message from the validation function and then accessed the `validationError` property to log this message.

バリデーションの関数から返される値はfalseではなく、モデルの`validationError`というプロパティを参照することが可能だ。上のコードでは、バリデーション関数からメッセージを返却し、`validationError`プロパティにアクセスすることでこのメッセージを出力している。

### Notes:

- A `validate` callback function is sent all of the models attributes as the first parameter, and the second parameter contains the options object from the `set()` or `save()` methods that trip the validation.
- Validation only occurs when using `save()`, the `set()` method and the `validation:true` option, or by manually running validation using `isValid()`.

- `validate`のコールバック関数の第一引数にはモデルの全ての属性が渡され、第二引数には`set()`や`save()`メソッドに渡されるバリデーションをトリップするオプションが渡される。
- バリデーションが実行されるのは、`save()`の実行時、`validation:true`を渡した`set()`メソッドの実行時、または`isValid()`で任意に実行する時である。

## 3.13 - Listening To A Model's `invalid` Event

The built in `invalid` event will be broadcasted when a model's `validate` function fails. In the code below I demonstrate listening for this event and then log the parameters passed to the invalid callback function.

モデルの`validate`関数が失敗すると、ビルドインの`invalid`イベントが発生し伝播する。コード例では、このイベントを監視し、渡されたパラメータを出力するコールバック関数を指定している。

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/3XkY4/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## 3.14 - Manually Run `validate` On Model

## 3.14 - モデルの`validate`の任意実行

The `validate` function can be manually invoked by calling the `isValid()` method. In the code example below the `validate` function is set up when extending the `Backbone.model` constructor so that all model instances can make use of the validate function. To make sure that data is always validated, I am running the `validate` function when the `initialize` function is called to catch any invalid data that is passed during the creation of the model instance.

`validate`関数は`isValid()`メソッドを実行することで任意に実行することが出来る。コードサンプルでは、`Backbone.Model`コンストラクタの拡張時に`validate`関数を設定してあり、生成されるインスタンスはvalidate関数を利用できる。データが常にバリデートされるよう、`initialize`関数の中で`validate`関数を実行し、インスタンス作成時に無効なデータが渡されるとそれを捕捉するようにしている。

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/NKnQ8/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

Notice that the `isValid()` method returns a helpful boolean indicating if the model is valid or not.

`isValid()`はモデルが有効かどうかを返す便利なメソッドであることを覚えておこう。

### Notes:

- The `save()` and `set()` internally make use of the validate function.
- `save()`と`set()`メソッドでも内部的にバリデート関数が使われている。
